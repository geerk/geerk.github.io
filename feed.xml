<?xml version="1.0" encoding="UTF-8"?>

    <feed xmlns="http://www.w3.org/2005/Atom">
        <title>Труханов блог</title>
        
        <link rel="alternate" href="http://blog.trukhanov.net/" />
        <link rel="self" href="http://blog.trukhanov.net/feed.xml" type="application/atom+xml" />
        <id>http://blog.trukhanov.net/</id>
        <updated>2013-08-24T13:46:51Z</updated>
        
        <author>
            <name>Timofey Trukhanov</name>
            <email>timofey.trukhanov@gmail.com</email>
            <uri>http://blog.trukhanov.net/</uri>
        </author>
        
        
            <entry>
                <title>Кеширование методов и функций между запросами в джанго</title>
                <link rel="alternate" href="http://blog.trukhanov.net/Keshirovaniye-metodov-i-funktsiy-mezhdu-zaprosami-v-Dzhango/" type="text/html" />
                <id>http://blog.trukhanov.net/Keshirovaniye-metodov-i-funktsiy-mezhdu-zaprosami-v-Dzhango/</id>
                <updated>2013-08-24T13:45:00Z</updated>
                
                <summary type="html">Ранее, в &lt;a href=&#34;http://blog.trukhanov.net/Keshirovanie-metodov-modeli-v-Django/&#34;&gt;одном&lt;/a&gt; из предыдущих постов, я рассказывал о том как кешировать результаты выполнения запросов в методах моделей в пределах одного запроса веб-страницы. В этом же посте я расскажу как можно кешировать результаты выполнения функций или методов на более длительный период времени.</summary>
                <content type="html">&lt;p&gt;Ранее, в &lt;a href=&#34;http://blog.trukhanov.net/Keshirovanie-metodov-modeli-v-Django/&#34;&gt;одном&lt;/a&gt; из предыдущих постов, я рассказывал о том как кешировать результаты выполнения запросов в методах моделей в пределах одного запроса веб-страницы. В этом же посте я расскажу как можно кешировать результаты выполнения функций или методов на более длительный период времени.&lt;/p&gt;

&lt;p&gt;В джанго &lt;a href=&#34;https://docs.djangoproject.com/en/1.5/topics/cache/#django-s-cache-framework&#34;&gt;доступно&lt;/a&gt; четыре способа кеширования. С помощью них можно кешировать:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Весь сайт&lt;/li&gt;
&lt;li&gt;Целые страницы&lt;/li&gt;
&lt;li&gt;Отдельные части шаблонов&lt;/li&gt;
&lt;li&gt;Что угодно, вручную управляя кешем&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Если есть возможность, лучше использовать первые три способа кеширования, т.к. они позволяют наиболее удобно и эффективно кешировать большой объем информации. Но в крайнем случае можно использовать и четвертый способ, чем мы сейчас и займемся.&lt;/p&gt;

&lt;p&gt;Итак, для кеширования функций, я написал простенький декоратор, который использует &lt;a href=&#34;https://docs.djangoproject.com/en/1.5/topics/cache/#the-low-level-cache-api&#34;&gt;ручной интерфейс&lt;/a&gt; кеширования в джанго. Однако для начала нужно сгенерировать ключ кеширования из входных аргументов функции. В предложенной реализации я использую встроенную функцию &lt;a href=&#34;http://docs.python.org/2/library/functions.html#hash&#34;&gt;hash&lt;/a&gt;, которая используется для быстрого сравнения ключей в словарях. Вместо нее можно также взять функцию md5-хеширования из стандартной библиотеки &lt;a href=&#34;http://docs.python.org/2/library/hashlib.html&#34;&gt;hashlib&lt;/a&gt;, что и делает джанго для генерирования ключей кеширования в первых трех способах. Особенностью функции &lt;code&gt;hash&lt;/code&gt; является то, что она вычисляет хеш только по неизменяемым структурам данных (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt; и т.д.).&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;def get_cache_key(prefix, *args, **kwargs):
    hash_args_kwargs = hash(tuple(kwargs.iteritems()) + args)
    return &amp;#x27;{}_{}&amp;#x27;.format(prefix, hash_args_kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Так как &lt;code&gt;kwargs&lt;/code&gt; приходят в виде словаря, приходится преобразовывать их в &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;args&lt;/code&gt; приходят уже в виде &lt;code&gt;tuple&lt;/code&gt;, поэтому в преобразовании нет необходимости. Следует заметить, что аргументами такой функции могут быть только хешируемые типы данных (из-за ограничений функции &lt;code&gt;hash&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Префикс нужен в том случае, если вы хотите именовать начало кеш-ключей для читаемости и уменьшения вероятности совпадения ключей при одинаковых аргументах различных функций. По умолчанию в качестве префикса используется имя функции.&lt;/p&gt;

&lt;p&gt;Сам же кеширующий декоратор выглядит следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;from functools import wraps

from django.core.cache import cache


def cache_func(func, timeout=500, prefix=&amp;#x27;&amp;#x27;):
    @wraps(func)
    def wrapper(*args, **kwargs):
        cache_key = get_cache_key(prefix or func.__name__, *args, **kwargs)
        cached_value = cache.get(cache_key)
        if cached_value is None:
            cached_value = func(*args, **kwargs)
            cache.set(cache_key, cached_value, timeout)
        return cached_value
    return wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Сначала на основе аргументов функции вычисляется ключ кеширования, потом проверяется наличие в кеше записи с таким ключом. Если такой записи нет, то вызывается функция и результат записывается в кеш. При последующих вызовах этой функции она уже не будет вызываться, вместо этого результат выполнения этот функции будет браться из кеша. Этот декоратор также можно применять и к методам классов при помощи другого декоратора: &lt;a href=&#34;https://docs.djangoproject.com/en/1.5/ref/utils/#django.utils.decorators.method_decorator&#34;&gt;&lt;code&gt;method_decorator&lt;/code&gt;&lt;/a&gt; из стандартной поставки джанго.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;P.S.&lt;/em&gt;: В третьем пайтоне есть похожий декоратор для кеширования результатов выполенния функций, но хранящий данные в обычном словаре в оперативной памяти: &lt;a href=&#34;http://docs.python.org/3.3/library/functools.html#functools.lru_cache&#34;&gt;lru_cache&lt;/a&gt;.&lt;/p&gt;
</content>
            </entry>
        
            <entry>
                <title>Условные подзапросы в Джанго</title>
                <link rel="alternate" href="http://blog.trukhanov.net/Uslovnye-podzaprosy-v-Django/" type="text/html" />
                <id>http://blog.trukhanov.net/Uslovnye-podzaprosy-v-Django/</id>
                <updated>2013-08-18T19:44:00Z</updated>
                
                <summary type="html">Часто к моделям в Джанго нужно дописывать вычисляемые свойства (например: &lt;code&gt;has_users&lt;/code&gt;, &lt;code&gt;has_votes&lt;/code&gt;, &lt;code&gt;articles_count&lt;/code&gt;, &lt;code&gt;avg_price&lt;/code&gt; и т.д.). Как правило эти свойства вычисляются по какому-либо условию на основании полей модели или зависимых моделей, которые можно подтянуть с помощью &lt;code&gt;select_related&lt;/code&gt; и это не приведет к увеличению числа запросов к базе данных. Но иногда необходимо вычислять такие свойства на основании данных из обратных связей (см. &lt;a href=&#34;https://docs.djangoproject.com/en/1.5/ref/models/relations/#django.db.models.fields.related.RelatedManager&#34;&gt;RelatedManager&lt;/a&gt;). В таких случаях простой способ с написанием дополнительных методов к модели может привести к линейному увеличению запросов к базе пропорционально увеличению количества объектов этой модели на странице.</summary>
                <content type="html">&lt;p&gt;Часто к моделям в Джанго нужно дописывать вычисляемые свойства (например: &lt;code&gt;has_users&lt;/code&gt;, &lt;code&gt;has_votes&lt;/code&gt;, &lt;code&gt;articles_count&lt;/code&gt;, &lt;code&gt;avg_price&lt;/code&gt; и т.д.). Как правило эти свойства вычисляются по какому-либо условию на основании полей модели или зависимых моделей, которые можно подтянуть с помощью &lt;code&gt;select_related&lt;/code&gt; и это не приведет к увеличению числа запросов к базе данных. Но иногда необходимо вычислять такие свойства на основании данных из обратных связей (см. &lt;a href=&#34;https://docs.djangoproject.com/en/1.5/ref/models/relations/#django.db.models.fields.related.RelatedManager&#34;&gt;RelatedManager&lt;/a&gt;). В таких случаях простой способ с написанием дополнительных методов к модели может привести к линейному увеличению запросов к базе пропорционально увеличению количества объектов этой модели на странице.&lt;/p&gt;

&lt;p&gt;К сожалению Джанго пока не предоставляет возможности через &lt;a href=&#34;http://ru.wikipedia.org/wiki/ORM&#34;&gt;ORM&lt;/a&gt; получить дополнительное поле, вычисляемое на основании проверки условия. &lt;a href=&#34;https://code.djangoproject.com/ticket/11305&#34;&gt;Запрос (ticket 11305)&lt;/a&gt; на подобный функционал висит в багтрекере Джанго, но неизвестно когда он попадет в основную ветку разработки. В общем случае проблему условных свойств можно решить несколькими способами.&lt;/p&gt;
&lt;h3&gt;Способ 1. Использование отдельных запросов для каждого объекта.&lt;/h3&gt;
&lt;p&gt;Этот способ заключается в написании дополнительного метода для модели, в котором используется &lt;code&gt;RelatedManager&lt;/code&gt;, фильтруется связанная модель и вычисляется агрегированное значение. Как уже говорилось выше, этот способ прост в реализации, но абсолютно неэффективен с точки зрения количества запросов к базе данных.&lt;/p&gt;
&lt;h3&gt;Способ 2. Использование одного отдельного запроса.&lt;/h3&gt;
&lt;p&gt;В этом способе выполняется один отдельный запрос на получение данных для всех объектов модели, после чего нужно присвоить результаты этого запроса для каждого объекта модели в цикле вручную. Здесь делается всего один дополнительный запрос к БД, но реализация выглядит ужасно (приходится проходить циклом по списку объектов и вручную присваивать объектам модели нужные поля). Кроме того этот подход плохо работает с пагинацией, так как кроме основного списка объектов нужно еще и пагинировать список дополнительных полей, полученных отдельным запросом.&lt;/p&gt;
&lt;h3&gt;Способ 3. Использование приложения &lt;a href=&#34;https://github.com/henriquebastos/django-aggregate-if/&#34;&gt;django-aggregate-if&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Самый простой способ. Для получения необходимого функционала, достаточно установить приложение &lt;a href=&#34;https://github.com/henriquebastos/django-aggregate-if/&#34;&gt;django-aggregate-if&lt;/a&gt;, которое реализует предложенное решение в &lt;a href=&#34;https://code.djangoproject.com/ticket/11305&#34;&gt;ticket 11305&lt;/a&gt; и использовать агрегирующие функции из модуля &lt;code&gt;aggregate_if&lt;/code&gt;. Рассмотрим на примере моделей из &lt;a href=&#34;https://docs.djangoproject.com/en/1.5/intro/tutorial01/&#34;&gt;Django Tutorial&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;# models.py
from django.db import models


class Poll(models.Model):
    question = models.CharField(max_length=200)
    pub_date = models.DateTimeField(&amp;#x27;date published&amp;#x27;, auto_now_add=True)

    def __str__(self):
        return self.question


class Choice(models.Model):
    poll = models.ForeignKey(Poll, related_name=&amp;#x27;choices&amp;#x27;)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    def __str__(self):
        return self.choice_text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Предположим, что нам нужно на странице списка опросов выводить информацию о том популярен ли опрос или нет. Причем популярность будем считать следующим образом: опрос является популярным, если хотя бы один из вариантов ответа набрал больше трех голосов (понятно что в реальном проекте скорее всего это будет считаться по-другому, но для примера условимся так). Тогда файл представлений (&lt;code&gt;views.py&lt;/code&gt;) будет выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;# views.py
from django.views.generic import ListView
from django.db.models import Q

from aggregate_if import Count

from .models import Poll


class PollListView(ListView):
    model = Poll

    def get_queryset(self):
        qs = super(PollListView, self).get_queryset()
        return qs.annotate(is_popular=Count(&amp;#x27;choices&amp;#x27;, only=Q(choices__votes__gt=3)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;С помощью этого кода каждому объекту модели &lt;code&gt;Poll&lt;/code&gt; будет добавлено поле &lt;code&gt;is_popular&lt;/code&gt;, которое по факту будет целочисленным, но использовать его можно и как булевое. Тогда в шаблоне можно помечать популярные опросы например так:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;django&#34;&gt;{% for poll in poll_list %}
    &amp;lt;p&amp;gt;{{ poll }} {% if poll.is_popular %}(Popular){% endif %}&amp;lt;&amp;#x2F;p&amp;gt;
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В таком случае на странице будет только один запрос, а выглядеть он будет примерно так:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;sql&#34;&gt;SELECT &amp;quot;polls_poll&amp;quot;.&amp;quot;id&amp;quot;,
       &amp;quot;polls_poll&amp;quot;.&amp;quot;question&amp;quot;,
       &amp;quot;polls_poll&amp;quot;.&amp;quot;pub_date&amp;quot;,
       COUNT(CASE WHEN &amp;quot;polls_choice&amp;quot;.&amp;quot;votes&amp;quot; &amp;gt; 3
                  THEN &amp;quot;polls_choice&amp;quot;.&amp;quot;id&amp;quot;
                  ELSE null END) AS &amp;quot;is_popular&amp;quot;
FROM &amp;quot;polls_poll&amp;quot; LEFT OUTER JOIN &amp;quot;polls_choice&amp;quot;
ON (&amp;quot;polls_poll&amp;quot;.&amp;quot;id&amp;quot; = &amp;quot;polls_choice&amp;quot;.&amp;quot;poll_id&amp;quot;)
GROUP BY &amp;quot;polls_poll&amp;quot;.&amp;quot;id&amp;quot;, &amp;quot;polls_poll&amp;quot;.&amp;quot;question&amp;quot;, &amp;quot;polls_poll&amp;quot;.&amp;quot;pub_date&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В зависимостях этого приложения указано, что оно требует &lt;code&gt;Django&amp;lt;1.5&lt;/code&gt;. Я попробовал его использовать вместе с &lt;code&gt;Django==1.5&lt;/code&gt; - оно работает, но во время выполнения запросов вываливается &lt;code&gt;DeprecationWarning&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Способ 4. Дополнение основного запроса подзапросом с условием при помощи метода &lt;a href=&#34;https://docs.djangoproject.com/en/1.5/ref/models/querysets/#extra&#34;&gt;extra&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Ну и наконец четвертый способ. Как известно, в документации Джанго не рекомендуют использовать &lt;a href=&#34;https://docs.djangoproject.com/en/1.5/ref/models/querysets/#extra&#34;&gt;extra&lt;/a&gt; и &lt;a href=&#34;https://docs.djangoproject.com/en/1.5/topics/db/sql/&#34;&gt;raw&lt;/a&gt; методы, но как будет видно дальше в подобных запросах не используется какой-то специфический синтаксис, который будет отличаться в разных базах данных. Кроме того смена базы данных - редкая необходимость. Поэтому рассмотрим и этот способ тоже. Модели и шаблоны остаются такими же, меняется только запрос к базе данных:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;# views.py
from django.views.generic import ListView

from .models import Poll


class PollListView(ListView):
    model = Poll

    def get_queryset(self):
        qs = super(PollListView, self).get_queryset()
        return qs.extra(select={&amp;#x27;is_popular&amp;#x27;: &amp;#x27;SELECT COUNT(*) FROM &amp;quot;polls_choice&amp;quot; &amp;#x27;
                                              &amp;#x27;WHERE &amp;quot;polls_choice&amp;quot;.&amp;quot;poll_id&amp;quot; = &amp;quot;polls_poll&amp;quot;.&amp;quot;id&amp;quot; &amp;#x27;
                                              &amp;#x27;AND &amp;quot;polls_choice&amp;quot;.&amp;quot;votes&amp;quot; &amp;gt; %s&amp;#x27;},
                        select_params=[3])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Следует отметить, что все подстановки нужно делать через специальный аргумент: &lt;code&gt;select_params&lt;/code&gt;, а самом запросе вставлять &lt;code&gt;%s&lt;/code&gt; для указания места подставновки. Таким образом драйвер базы данных экранирует эти параметры, что позволяет избежать &lt;a href=&#34;http://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_SQL-%D0%BA%D0%BE%D0%B4%D0%B0&#34;&gt;SQL-инъекций&lt;/a&gt;. Результирующий запрос будет выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;sql&#34;&gt;SELECT &amp;quot;polls_poll&amp;quot;.&amp;quot;id&amp;quot;,
       &amp;quot;polls_poll&amp;quot;.&amp;quot;question&amp;quot;,
       &amp;quot;polls_poll&amp;quot;.&amp;quot;pub_date&amp;quot;,
       (SELECT COUNT(*) FROM &amp;quot;polls_choice&amp;quot;
                        WHERE &amp;quot;polls_choice&amp;quot;.&amp;quot;poll_id&amp;quot; = &amp;quot;polls_poll&amp;quot;.&amp;quot;id&amp;quot;
                        AND &amp;quot;polls_choice&amp;quot;.&amp;quot;votes&amp;quot; &amp;gt; 3) AS &amp;quot;is_popular&amp;quot;
FROM &amp;quot;polls_poll&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Выводы&lt;/h2&gt;
&lt;p&gt;Условные подзапросы можно использовать не только для вычисления булевых полей как показано в примерах. Также можно добавлять любые агрегированные поля с условием(ями). Можно использовать стандартные операторы агрегации, такие как: COUNT, SUM, AVG и т.д.&lt;/p&gt;

&lt;p&gt;Надеюсь что в скором времени в Джанго добавят возможность выполнять условные подзапросы при помощи ORM. Пока же приходится либо жертвовать производительностью либо писать не очень красивый код.&lt;/p&gt;
</content>
            </entry>
        
            <entry>
                <title>Простой способ выделения активной вкладки меню в Джанго</title>
                <link rel="alternate" href="http://blog.trukhanov.net/Prostoy-sposob-vydeleniya-aktivnoy-vrladki-menu-v-Django/" type="text/html" />
                <id>http://blog.trukhanov.net/Prostoy-sposob-vydeleniya-aktivnoy-vrladki-menu-v-Django/</id>
                <updated>2013-07-12T14:06:00Z</updated>
                
                <summary type="html">Одна из частых задач при разработке типичного сайта - на разных страницах выделять текущий активный раздел сайта или меню. Это могут быть как просто разделы меню так и вкладки или что-то другое. Как правило для выделения вкладки прописывается дополнительный класс &lt;code&gt;active&lt;/code&gt; в css и выделением является присваивание этого класа нужному html-блоку при генерации страниц.</summary>
                <content type="html">&lt;p&gt;Одна из частых задач при разработке типичного сайта - на разных страницах выделять текущий активный раздел сайта или меню. Это могут быть как просто разделы меню так и вкладки или что-то другое. Как правило для выделения вкладки прописывается дополнительный класс &lt;code&gt;active&lt;/code&gt; в css и выделением является присваивание этого класа нужному html-блоку при генерации страниц.&lt;/p&gt;

&lt;p&gt;Самый простой способ это реализовать заключается в добавлении переменной &lt;code&gt;active_tab&lt;/code&gt; в контекст шаблона и в зависимости от значения этой переменной выделять нужную вкладку. Для упрощения добавления этой переменной можно написать простенький миксин:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;class ActiveTabMixin(object):
    &amp;quot;&amp;quot;&amp;quot;
    Mixin to set active tab menu
    &amp;quot;&amp;quot;&amp;quot;
    active_tab = None

    def get_active_tab(self):
        if self.active_tab is None:
            raise ImproperlyConfigured(
                &amp;quot;ActiveTabMixin requires either a definition of &amp;quot;
                &amp;quot;&amp;#x27;active_tab&amp;#x27; or an implementation of &amp;#x27;get_active_tab()&amp;#x27;&amp;quot;)
        return self.active_tab

    def get_context_data(self, **kwargs):
        context = super(ActiveTabMixin, self).get_context_data(**kwargs)
        context[&amp;#x27;active_tab&amp;#x27;] = self.get_active_tab()
        return context
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После чего можно &amp;ldquo;подмешивать&amp;rdquo; его в класс представлений (views) и с помощью атрибута класса определять активную вкладку для данной страницы.&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;class MeetingDetailView(ActiveTabMixin, DetailView):
    model = Meeting
    active_tab = &amp;#x27;meetings&amp;#x27;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Во избежание дублирования кода можно выделить специальный шаблон &lt;code&gt;menu.html&lt;/code&gt; и в нем генерировать вкладки, выделяя активную с помощью вышеописанного метода.&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li{% if active_tab == &amp;#x27;dashboard&amp;#x27; %} class=&amp;quot;active&amp;quot;{% endif %}&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Dashboard&amp;lt;&amp;#x2F;a&amp;gt;&amp;lt;&amp;#x2F;li&amp;gt;
    &amp;lt;li{% if active_tab == &amp;#x27;calendar&amp;#x27; %} class=&amp;quot;active&amp;quot;{% endif %}&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Calendar&amp;lt;&amp;#x2F;a&amp;gt;&amp;lt;&amp;#x2F;li&amp;gt;
    &amp;lt;li{% if active_tab == &amp;#x27;meetings&amp;#x27; %} class=&amp;quot;active&amp;quot;{% endif %}&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Meetings&amp;lt;&amp;#x2F;a&amp;gt;&amp;lt;&amp;#x2F;li&amp;gt;
    &amp;lt;li{% if active_tab == &amp;#x27;archives&amp;#x27; %} class=&amp;quot;active&amp;quot;{% endif %}&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Archives&amp;lt;&amp;#x2F;a&amp;gt;&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этот способ не универсальный и работает только в простых случаях одноуровневого меню. Можно такой же функционал завязать на URL текущей страницы, привязавшись либо к &lt;code&gt;namespace&lt;/code&gt; либо к имени URL. Но такой способ подразумевает детальную синхронизацию URL-ов и шаблонов.&lt;/p&gt;
</content>
            </entry>
        
            <entry>
                <title>Кеширование методов модели в Джанго</title>
                <link rel="alternate" href="http://blog.trukhanov.net/Keshirovanie-metodov-modeli-v-Django/" type="text/html" />
                <id>http://blog.trukhanov.net/Keshirovanie-metodov-modeli-v-Django/</id>
                <updated>2013-07-08T09:22:00Z</updated>
                
                <summary type="html">В книге &lt;a href=&#34;http://django.2scoops.org/&#34;&gt;Two scoops of Django&lt;/a&gt; советуют всю бизнесовую логику держать в моделях. И я с этим согласен, это действительно удобно. Один из самых простых методов реализации этого совета - написание дополнительных методов в модели для добавления необходимого поведения. Эти методы потом можно использовать как в контроллерах (views) так и в представлениях (templates).</summary>
                <content type="html">&lt;p&gt;В книге &lt;a href=&#34;http://django.2scoops.org/&#34;&gt;Two scoops of Django&lt;/a&gt; советуют всю бизнесовую логику держать в моделях. И я с этим согласен, это действительно удобно. Один из самых простых методов реализации этого совета - написание дополнительных методов в модели для добавления необходимого поведения. Эти методы потом можно использовать как в контроллерах (views) так и в представлениях (templates).&lt;/p&gt;

&lt;p&gt;В процессе создания приложения зачастую возникает необходимость вызывать эти методы по нескольку раз в разных местах программы. А если в этом методе происходит работа с базой данных, то это приводит к нежелательному дублированию одинаковых запросов. К счастью есть возможность избежать этого дублирования в пределах одного вызова контроллера.&lt;/p&gt;

&lt;p&gt;Например в модели &lt;code&gt;User&lt;/code&gt; нужен метод, возвращающий количество непрочитанных сообщений:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;def get_unread_message_count(self):
    return self.messages.filter(is_read=False).count()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Результат выполнения этого метода необходимо показать в разных частях страницы (возле логина, рядом с кнопкой перехода на страницу сообщений, еще где-нибудь). Соответственно каждый вызов метода будет делать запрос к базе данных. Чтобы этого избежать можно использовать кеширование результата запроса. Стандартная схема выглядит следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;def get_unread_message_count(self):
    if not hasattr(self, &amp;#x27;_cached_unread_message_count&amp;#x27;):
        self._cached_unread_message_count = self.messages.filter(is_read=False).count()
    return self._cached_unread_message_count
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;При первом вызове метода у модели не будет атрибута &lt;code&gt;_cached_unread_message_count&lt;/code&gt;, поэтому выполнится запрос к базе данных и результат сохранится в атрибут модели &lt;code&gt;_cached_unread_message_count&lt;/code&gt;. При повторном вызове этого метода у модели уже будет этот атрибут, в котором будет храниться результат выполнения предыдущего раза. И вместо выполнения запроса еще раз метод вернет закешированный результат первого вызова.&lt;/p&gt;

&lt;p&gt;Такой подход позволяет сократить количество повторяющихся запросов к базе данных в пределах одного запроса к Джанго серверу. Естественно при обновлении страницы этот метод выполнит запрос к базе данных еще раз. Для того, чтобы кешировать данные на более длительный период необходимо использовать &lt;a href=&#34;https://docs.djangoproject.com/en/1.5/topics/cache/&#34;&gt;стандартное кеширование&lt;/a&gt;.&lt;/p&gt;
</content>
            </entry>
        
            <entry>
                <title>Таймстампы в пайтоне</title>
                <link rel="alternate" href="http://blog.trukhanov.net/Python-timestamps/" type="text/html" />
                <id>http://blog.trukhanov.net/Python-timestamps/</id>
                <updated>2013-06-09T05:39:00Z</updated>
                
                <summary type="html">Однажды в одном проекте мне понадобилось преобразовать &lt;code&gt;utc datetime&lt;/code&gt; в &lt;code&gt;unix timestamp&lt;/code&gt;.&lt;br&gt;
Сразу оговорюсь что описанное ниже относится к Python 2.7.</summary>
                <content type="html">&lt;p&gt;Однажды в одном проекте мне понадобилось преобразовать &lt;code&gt;utc datetime&lt;/code&gt; в &lt;code&gt;unix timestamp&lt;/code&gt;.&lt;br&gt;
Сразу оговорюсь что описанное ниже относится к Python 2.7.&lt;/p&gt;

&lt;p&gt;Если просто погуглить, то везде советуют следующий способ:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;from datetime import datetime
import time

now = datetime.now()
timestamp = time.mktime(now.timetuple())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Все это правильно, но кто же пользуется локальным временем?&lt;br&gt;
У меня естественно время в utc, поэтому следующий код с точки зрения использования модуля &lt;code&gt;time&lt;/code&gt; является неправильным:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;from datetime import datetime
import time

utcnow = datetime.utcnow()
timestamp = time.mktime(utcnow.timetuple())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А выяснилось это только тогда, когда мне пришлось сравнивать этот таймстамп с другим таймстампом, созданным другим программистом. А создавал он его вот так:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;import time

timestamp = int(time.time())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И действительно, если погуглить на тему как получить юникс таймстамп в пайтоне, то именно это вы и найдете, однако такой способ правильный только в том случае, если вы везде используете локальное время, но кто же его использует? Соответственно разница между моим таймстампом и таймстампом этого программиста получилась 3 часа.&lt;/p&gt;
&lt;h1&gt;Документация&lt;/h1&gt;
&lt;p&gt;Далее обращаемся к &lt;a href=&#34;http://docs.python.org/2/library/time.html&#34;&gt;документации пайтона по модулю time&lt;/a&gt; и обнаруживаем, что к функции &lt;code&gt;time.time()&lt;/code&gt; вообще не написано какое время она возвращает - локальное или глобальное. Зато есть две другие функции: &lt;code&gt;time.localtime()&lt;/code&gt; и &lt;code&gt;time.gmtime()&lt;/code&gt;. Тут из названия очевидно какое время какая функция возвращает. Но! Обе эти функции возвращают не число, а &lt;a href=&#34;http://docs.python.org/2/library/time.html#time.struct_time&#34;&gt;struct_time&lt;/a&gt;.&lt;br&gt;
А если почитать документацию к функции &lt;code&gt;time.mktime()&lt;/code&gt;, то выясняется что эта функция ожидает в качестве аргумента &lt;a href=&#34;http://docs.python.org/2/library/time.html#time.struct_time&#34;&gt;struct_time&lt;/a&gt; в &lt;strong&gt;локальном&lt;/strong&gt; времени. Логично предположить, что должна быть симметричная функция &lt;code&gt;time.mktimegm()&lt;/code&gt; или что-то подобное. Но не тут то было. Оказывается чтобы преобразовать &lt;a href=&#34;http://docs.python.org/2/library/time.html#time.struct_time&#34;&gt;struct_time&lt;/a&gt; в &lt;strong&gt;глобальном&lt;/strong&gt; времени необходимо обращаться к функции из совершенно другого модуля, а именно к &lt;code&gt;calendar.timegm()&lt;/code&gt;. Что за черт?&lt;/p&gt;

&lt;p&gt;В документации даже можно найти такую табличку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;From                     | To                        | Use
-------------------------|---------------------------|------------------
seconds since the epoch  | struct_time in UTC        | gmtime()
seconds since the epoch  | struct_time in local time | localtime()
struct_time in UTC       | seconds since the epoch   | calendar.timegm()
struct_time in local time| seconds since the epoch   | mktime()
&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;Неочевидности&lt;/h1&gt;&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;import time
import calendar
from datetime import datetime

ts1 = time.mktime(datetime.utcnow().timetuple())  # неправильно!
ts2 = calendar.timegm(datetime.utcnow().timetuple())  # правильно!

ts3 = time.mktime(time.gmtime())  # неправильно!
ts4 = calendar.timegm(time.gmtime())  # правильно!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Казалось бы, теперь все прояснилось и стало все понятно, однако:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;print((ts1 - ts2) &amp;#x2F; 60 &amp;#x2F; 60)  # -3.0
print((ts3 - ts4) &amp;#x2F; 60 &amp;#x2F; 60)  # -2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В первом случае разница между правильным и неправильным вариантом оказалась 3 часа, а во втором случае 2 часа.&lt;/p&gt;
&lt;h1&gt;Выводы&lt;/h1&gt;
&lt;p&gt;Получение глобального таймстампа используя модули &lt;code&gt;time&lt;/code&gt; и &lt;code&gt;calendar&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;import calendar
import time

utc_struct_time = time.gmtime()
utc_ts = calendar.timegm(utc_struct_time)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Получение глобального таймстампа используя модули &lt;code&gt;datetime&lt;/code&gt; и &lt;code&gt;calendar&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code data-lang=&#34;python&#34;&gt;import calendar
from datetime import datetime

utc_dt = datetime.utcnow()
utc_ts = calendar.timegm(utc_dt.timetuple())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И проверяйте то, что пишут в блогах перед тем как использовать :)&lt;/p&gt;
</content>
            </entry>
        
    </feed>
